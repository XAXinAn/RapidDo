# OCR 性能优化指南 (v1.0 经验总结)

针对悬浮窗 OCR 推理耗时过长（如 2.5s）的问题，本指南总结了 v1.0 项目中的核心优化策略，旨在将推理耗时降低至数百毫秒级别。

## 1. 分辨率与预处理优化

*   **输入缩放**：禁止直接将全屏高分辨率位图送入 OCR。建议将长边缩放至 **960px** 以内。
*   **ROI 裁剪**：仅对用户选中的区域（Region of Interest）进行识别，而非全屏。
*   **颜色空间**：`ImageReader` 直接使用 `PixelFormat.RGBA_8888`，避免 YUV 转 RGB 的额外计算。

## 2. 模型选型与配置

*   **模型版本**：推荐使用 **PP-OCRv3** 或 **PP-OCRv4** 移动版模型。
*   **精度选择**：强制开启 **FP16** 精度（在 CPU 上加速明显）。
*   **方向分类 (cls)**：若业务场景不涉及旋转文字，建议**关闭 cls 模型**，可节省约 10-20% 的耗时。

## 3. 硬件加速与线程管理

*   **线程数**：建议配置为 **4 线程**。
*   **CPU 亲和性**：使用 `PowerMode.LITE_POWER_HIGH` 提升处理优先级。
*   **异步调度**：确保 OCR 在 `Dispatchers.IO` 或独立线程中运行，主线程仅负责 UI 渲染。

## 4. 关键参数推荐

| 参数名称 | 推荐值 | 说明 |
| :--- | :--- | :--- |
| `cpuThreadNum` | 4 | 兼顾性能与功耗 |
| `precision` | FP16 | 浮点运算加速 |
| `isRunCls` | false | 除非需要检测文字方向 |
| `det_db_thresh` | 0.3 | 检测框阈值 |
| `det_db_box_thresh` | 0.5 | 检测框过滤阈值 |

## 5. 运行开销优化

*   **预热 (Warm-up)**：在引擎初始化后，送入一张 1x1 的空白图片进行一次“空识别”，以触发 NDK 资源加载。
*   **日志控制**：在生产环境关闭 NDK 层的推理日志输出。
*   **缓冲复用**：使用 `acquireLatestImage()` 确保只处理最新帧，避免帧堆积。

## 6. 构建优化

*   **ABI 过滤**：仅保留 `arm64-v8a` 和 `armeabi-v7a`。
*   **静态链接**：使用 `c++_static.with_extra` 版本的 Paddle Lite SDK，减少动态库加载开销。

---
*注：以上数据基于 v1.0 项目实测经验，具体数值需根据 2.0 实际机型表现进行微调。*
