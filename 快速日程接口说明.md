# 快速日程接口说明

## 背景

悬浮窗 OCR 截屏场景是"快速添加日程"，不需要会话历史。现有流程每次都创建新会话存在以下问题：

1. **多一次网络请求**（创建会话 ~100-200ms）
2. **积累无用会话**（会话列表越来越长）
3. **上下文没意义**（快速日程不需要多轮对话）

## 新增接口：快速日程识别

**目的**：为悬浮窗 OCR 截屏场景提供无状态的快速日程添加能力，不创建会话、不存储消息历史。

---

## 接口定义

```
POST /api/ai/quick-schedule
```

## 请求头

| Header | 值 | 说明 |
|--------|-----|------|
| Authorization | Bearer {accessToken} | 用户认证令牌 |
| Content-Type | application/json | |
| Accept | text/event-stream | SSE 流式响应 |

## 请求体

```json
{
  "text": "OCR识别的文本内容，例如：12月23日下午14:00将举行学院的妇联换届大会..."
}
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| text | String | 是 | OCR 识别出的原始文本 |

## 处理逻辑

1. **从 JWT 解析 userId**
2. **构造 AI 请求**：
   - 使用与现有 `sendMessageStream` 相同的 system prompt（日程助手）
   - 消息内容固定为：`"帮我添加日程：" + text`
   - **不存储到 chat_sessions / chat_messages 表**
   - **不需要 sessionId**
3. **调用 AI 模型**（流式）：
   - 模型会通过 function call 调用 `createSchedule` 工具
   - 工具执行时仍需要 userId 来创建日程
   - 可以传一个固定的占位 sessionId（如 `"quick-schedule"`）给工具，或在工具内特殊处理
4. **流式返回 SSE**：格式与现有接口一致

## SSE 响应格式

```
data: {"content": "✅", "done": false}
data: {"content": " 已添加日程", "done": false}
data: {"content": "：12月23日", "done": false}
...
data: {"content": "", "done": true}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| content | String | 流式返回的文本片段 |
| done | Boolean | 是否完成 |

## 错误响应

### 401 未授权

```json
{
  "code": 401,
  "message": "未登录或令牌无效"
}
```

### 400 参数错误

```json
{
  "code": 400,
  "message": "text 不能为空"
}
```

---

## 与现有接口对比

| | 现有 sendMessageStream | 新 quick-schedule |
|---|---|---|
| 路径 | `/ai/sessions/{sessionId}/messages` | `/ai/quick-schedule` |
| 需要 sessionId | ✅ 需要先创建会话 | ❌ 不需要 |
| 存储消息 | ✅ 存入 chat_messages | ❌ 不存储 |
| 创建会话 | 需要先调用 createSession | 不需要 |
| 适用场景 | 多轮对话 | 悬浮窗快速添加日程 |

---

## 参考实现

### Controller

```java
@PostMapping("/ai/quick-schedule")
public SseEmitter quickSchedule(
    @RequestBody QuickScheduleRequest request,
    HttpServletRequest httpRequest
) {
    String userId = extractUserIdFromToken(httpRequest);
    String text = request.getText();
    
    if (text == null || text.isBlank()) {
        throw new BadRequestException("text 不能为空");
    }
    
    String prompt = "帮我添加日程：" + text;
    
    // 复用现有的 AI 调用逻辑，但不存储消息
    return aiChatService.streamWithoutSession(userId, prompt);
}
```

### Request DTO

```java
@Data
public class QuickScheduleRequest {
    private String text;
}
```

### Service 新增方法

```java
public SseEmitter streamWithoutSession(String userId, String prompt) {
    SseEmitter emitter = new SseEmitter(300000L); // 5分钟超时
    
    executor.execute(() -> {
        try {
            // 1. 构造 system prompt（复用现有的日程助手 prompt）
            String systemPrompt = buildSystemPrompt(userId, null); // sessionId 传 null 或固定值
            
            // 2. 构造消息列表（只有 system + user，无历史）
            List<Message> messages = List.of(
                new SystemMessage(systemPrompt),
                new UserMessage(prompt)
            );
            
            // 3. 调用 AI 模型（复用现有流式调用逻辑）
            // 4. 处理 function call（createSchedule 工具需要 userId）
            // 5. 流式返回结果
            
            streamAiResponse(emitter, messages, userId);
            
        } catch (Exception e) {
            emitter.completeWithError(e);
        }
    });
    
    return emitter;
}
```

### 工具调用注意事项

`createSchedule` 工具需要 `userId` 来创建日程。有两种处理方式：

**方式1：使用固定占位 sessionId**

```java
// 在 system prompt 中传入固定值
String sessionId = "quick-schedule-" + userId;
```

**方式2：工具内特殊处理**

```java
// CalendarTools.createSchedule 中判断
if (sessionId == null || sessionId.startsWith("quick-schedule")) {
    // 不关联会话，直接使用 userId 创建日程
}
```

---

## 注意事项

1. **工具调用**：`createSchedule` 工具仍需正常执行，只是不关联会话
2. **userId 传递**：工具需要 userId 来创建日程，确保从 JWT 解析并传入
3. **无历史上下文**：每次请求都是独立的，不需要加载历史消息
4. **性能提升**：省去创建会话和存储消息的开销，预计减少 100-300ms

---

## 前端已完成的改动

悬浮窗 `FloatingResultDialog.kt` 已改为直接调用 `/api/ai/quick-schedule`：

- 移除了 `createSession()` 方法
- 移除了 `sendMessageToAi()` 方法
- 新增 `callQuickSchedule()` 方法，直接 POST 到新接口
- 请求体格式：`{"text": "OCR文本"}`
- 响应解析逻辑不变（SSE 流式）
